/**
 * The algorithm X that applied the dancing-link, it is also called as "DLX".
 * It is used to solve the exact-cover problem.
 *
 * Dancing-link: A cross doubly linked list, each column has a virtual node as
 * the head pointer, and at the top of all virtual nodes there is an additional
 * virtual node as the head pointer of the virtual node, which is also the head
 * pointer of the entire dancing-link. In the implementation of using an array
 * to simulate a linked list, the virtual node is represented by a column
 * number, and the head pointer of the dancing-link can be represented by 0.
 *
 * @see https://me.guanghechen.com/post/algorithm/dlx/
 */
interface IDancingLinkX {
    /**
     * Release memory variables.
     */
    destroy(): void;
    /**
     * Initialize the dancing-link.
     * @param columnCount number of columns
     */
    init(columnCount: number): void;
    /**
     * Add a row to the dancing-link.
     *
     * It should be noted that after solving the exact-cover problem, the
     * result is a list of selected row numbers, so the row number should be
     * specified as a value that can carry information.
     *
     * @param rowNo     the row number
     * @param columns   columns on the row
     */
    addRow(rowNo: number, columns: ReadonlyArray<number>): void;
    /**
     * Try to find a precise coverage.
     *
     * When a solution is found, return the row numbers of all selected rows,
     * otherwise return null.
     */
    solve(): number[] | null;
}

interface IDancingLinkXProps {
    /**
     * Maximum number of nodes in the dancing-link.
     */
    MAX_N: number;
}
/**
 * An implementation of the Dancing-Link algorithm.
 *
 * !!!NOTE
 *  - Row number start from 1.
 *  - Column number start from 1.
 */
declare class DancingLinkX implements IDancingLinkX {
    protected readonly _count: number[];
    protected readonly _row: number[];
    protected readonly _col: number[];
    protected readonly _L: number[];
    protected readonly _R: number[];
    protected readonly _U: number[];
    protected readonly _D: number[];
    protected _sz: number;
    constructor(props: IDancingLinkXProps);
    destroy(): void;
    init(columnCount: number): void;
    addRow(r: number, columns: ReadonlyArray<number>): void;
    solve(): number[] | null;
    /**
     * Algorithm X.
     *
     * Recursively solve the problem of precise coverage, enumerate which rows are
     * selected in the recursive process, remove the selected rows and all the
     * columns on the rows, and restore these rows and columns during the
     * backtrack.
     *
     * @param dep   recursion depth
     * @private
     */
    protected _algorithmX(dep: number, selectedRowNos: number[]): boolean;
    /**
     * Remove a column from the dancing-link.
     * @param c   column number
     * @private
     */
    protected _removeColumn(c: number): void;
    /**
     * Restore a previously deleted column
     * @param c   column number
     * @private
     */
    protected _restoreColumn(c: number): void;
}

export { DancingLinkX, IDancingLinkX, IDancingLinkXProps };
