import { IDancingLinkX } from '@algorithm.ts/dlx';

/**
 * For x^2 \times x^2 sudoku board
 *
 * - BASE_1 = x
 * - BASE_2 = x^2
 * - BASE_3 = x^3
 * - BASE_4 = x^4
 *
 * // alias
 * - MATRIX_RANK = BASE_1 = x
 * - MATRIX = BASE_2 = x^2
 * - BOARD = BASE_4 = x^4
 */
interface ISudokuSize {
    readonly BASE_1: number;
    readonly BASE_2: number;
    readonly BASE_3: number;
    readonly BASE_4: number;
    readonly MATRIX_RANK: number;
    readonly MATRIX: number;
    readonly BOARD: number;
}
/**
 * Sudoku game board.
 */
type ISudokuBoardData = number[];
/**
 * A sudoku game data.
 */
interface ISudokuData {
    /**
     * Sudoku puzzle.
     */
    puzzle: ISudokuBoardData;
    /**
     * Solution of the sudoku puzzle.
     */
    solution: ISudokuBoardData;
}

/**
 * Sudoku constraints.
 */
declare const enum SudokuConstraint {
    SLOT = 0,
    ROW = 1,
    COL = 2,
    SUB = 3
}
interface ISudokuSolverOptions {
    /**
     * Size of the child puzzle matrix (sqrt of original puzzle size)
     */
    readonly childMatrixWidth: number;
}
declare class SudokuSolver {
    readonly size: Readonly<ISudokuSize>;
    readonly DL_TOTAL_COLUMNS: number;
    protected readonly dlx: IDancingLinkX;
    protected readonly matCodeMap: ReadonlyArray<number>;
    protected readonly constraints: SudokuConstraint[];
    constructor(options: ISudokuSolverOptions);
    /**
     * Try to solve the given Sudoku problem, if there is a solution, fill the
     * solution into the incoming `solution` board.
     *
     * In particular, you can use the same two-dimensional array to pass in as the
     * `puzzle` and `solution` parameters respectively. If there is a solution,
     * the solution will still be filled into the passed `solution` array.
     *
     * If the `solution` parameter is not passed in, the solution will be
     * discarded, which is equivalent to only judging whether there is a solution.
     *
     * @param puzzle
     * @param solution
     * @returns Whether there is a solution
     * @public
     */
    solve(puzzle: Readonly<ISudokuBoardData>, solution: ISudokuBoardData | null): boolean;
}

interface ISudokuCreatorOptions {
    /**
     * Size of the child puzzle matrix (sqrt of original puzzle size)
     */
    readonly childMatrixWidth: number;
    /**
     * The difficulty to solve the puzzle.
     * @default 0.2
     */
    difficulty?: number;
}
declare class SudokuCreator {
    readonly size: Readonly<ISudokuSize>;
    protected readonly solver: SudokuSolver;
    protected readonly matCoordinateMap: ReadonlyArray<number>;
    protected readonly gridCodes: number[];
    protected readonly candidates: number[];
    protected readonly availableNums: boolean[];
    protected readonly tmpBoard: ISudokuBoardData;
    protected difficulty: number;
    constructor(options: ISudokuCreatorOptions);
    /**
     * Create a sudoku game data.
     * @param difficulty
     * @returns
     */
    createSudoku(difficulty?: number): ISudokuData;
    /**
     * Create a full-filled sudoku data.
     * @returns
     */
    protected _createSolution(): ISudokuBoardData;
    /**
     * Create a sudoku puzzle that has only one unique solution.
     * @param solution
     * @returns
     */
    protected _createPuzzle(solution: Readonly<ISudokuBoardData>): ISudokuBoardData;
    /**
     * Calculate which numbers can be filled in a specified grid (r,c) in the
     * Sudoku board.
     *
     * For the sake of saving memory space, the number candidates are stored in
     * this.candidates, and the function only returns the number of candidates.
     *
     * @param board
     * @param p
     */
    protected _collectCandidates(board: Readonly<ISudokuBoardData>, p: number): number;
    /**
     * Resolve the value of difficulty.
     * @param _difficulty
     * @returns
     */
    protected _resolveDifficulty(_difficulty: number): number;
}

declare class SudokuSize implements ISudokuSize {
    readonly BASE_1: number;
    readonly BASE_2: number;
    readonly BASE_3: number;
    readonly BASE_4: number;
    readonly MATRIX_RANK: number;
    readonly MATRIX: number;
    readonly BOARD: number;
    constructor(SUDOKU_CHILD_MATRIX_WIDTH: number);
}

declare const createSudokuBoardData: (size: Readonly<ISudokuSize>) => ISudokuBoardData;
declare const fillSudokuBoardData: (board: ISudokuBoardData, value: number, size: Readonly<ISudokuSize>) => void;
declare const copySudokuBoardData: (srcBoard: Readonly<ISudokuBoardData>, dstBoard: ISudokuBoardData, size: Readonly<ISudokuSize>) => void;
declare const toMatrixStyleBoardData: (board: Readonly<ISudokuBoardData>, size: Readonly<ISudokuSize>) => number[][];
/**
 * In returned data (let's call it matCodeMap), matCodeMap[p]=x represent that the p-th element of
 * the sudoku board is belongs the x-th child-matrix of the sudoku board.
 * @param size
 * @returns
 */
declare function createMatrixCodeMap(size: Readonly<ISudokuSize>): number[];
/**
 * In returned data (let's call it matCoordinateMap), matCoordinateMap[p]=x represent that the p-th
 * element of the sudoku board is belongs the child-matrix which the left-top element index is x.
 * @param size
 * @returns
 */
declare function createMatrixCoordinateMap(size: Readonly<ISudokuSize>): number[];
declare function verifySolution(solution: Readonly<ISudokuBoardData>, size: Readonly<ISudokuSize>): boolean;

export { ISudokuBoardData, ISudokuCreatorOptions, ISudokuData, ISudokuSize, ISudokuSolverOptions, SudokuConstraint, SudokuCreator, SudokuSize, SudokuSolver, copySudokuBoardData, createMatrixCodeMap, createMatrixCoordinateMap, createSudokuBoardData, fillSudokuBoardData, toMatrixStyleBoardData, verifySolution };
